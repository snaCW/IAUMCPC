# ساختمان‌های داده STL

کتاب‌خانه‌ی استاندارد C++‎ ساختمان داده‌هایی در اختیار ما قرار می‌دهد که با آن‌ها می‌توانیم مسائل را خیلی ساده‌تر حل کنیم.

## فهرست

- [`std::vector`](#stdvector)
    - [مزایای `vector`](#مزایای-vector)
    - [نکات استفاده از `vector`](#نکات-استفاده-از-vector)
    - [نمونه مسئله](#نمونه-مسئله)

## `std::vector`

`std::vector` ساختمان داده‌ای است که آرایه‌ای با اندازه‌ی قابل‌تغییر ارائه می‌کند. مزیت `vector` در این است که نیازی به دانستن اندازه‌ی اولیه ندارد. به کد زیر نگاه کنید.

```cpp
#include <iostream>

using namespace std;

int main() {
    int n;
    cin >> n;

    int arr[n];

    return 0;
}
```

در خط تعریف آرایه، از مقدار `n` که تنها در هنگام runtime مشخص می‌شود استفاده شده.

> مقداری که در هنگام runtime مشخص شود، تنها در حین اجرای برنامه مشخص می‌شود. همانند دستور خواندن.

استفاده از متغیر با مقدار مشخص‌شده در runtime برای تعریف آرایه، در C++‎ استاندارد وجود ندارد! بعضی از کامپایلرها چنین مشکلی ندارند، اما این هیچ تضمینی نمی‌دهد که در محیطی که قرار است برنامه اجرا شود (توسط یک نفر دیگر یا سایت) آیا از همان کامپایلر استفاده شده یا نه.

بهتر است همیشه سعی کنیم از استانداردهای C++‎ پیروی کنیم تا مشکلی پیش نیاید. این‌جاست که `vector` خودش را نشان می‌دهد.

```cpp
#include <iostream>
#include <vector>

using namespace std;

int main() {
    int n;
    cin >> n;

    vector<int> arr(n);

    return 0;
}
```

از آن‌جایی که کد بالا از شیوه‌ی استاندارد و امن تعریف آرایه با اندازه‌ی نامشخص در هنگام کامپایل استفاده کرده، همواره تضمین عملکرد داریم.

### مزایای `vector`

شاید در نگاه اول، استفاده از آرایه‌ی عادی ساده‌تر باشد. به جدول زیر برای مقایسه‌های توانایی‌های این دو دقت کنید. هر مورد توضیح داده می‌شود.

| ویژگی | `std::vector<T>‎` | `T[]‎` | `T*‎` |
| - | - | - | - |
| تخصیص حافظه | پویا (خودکار) | ساکن | پویا |
| اندازه | قابل‌تغییر در runtime | ثابت | ثابت |
| بررسی حدها | امن از طریق `.at()` | نه | نه |
| راحتی استفاده | وجود متودهای بسیار | بسیار کم | بسیار کم |
| مقداردهی اولیه | ساده: `vector<int> v(n, 0)` | حلقه یا `{}` | حلقه یا `{}` |
| مدیریت حافظه | خودکار | دستی | دستی (نیاز به `new` و `delete[]`) |
| تطابق با بقیه‌ی کتاب‌خانه‌ها | بسیار زیاد | محدود | محدود |
| کپی | عمیق | ظاهری | ظاهری |

با ۳ روش تعریف آرایه آشنا شدید. اگر تایپ آرایه از جنس `T` باشد (می‌تواند `int` باشد یا هر چیزی)، داریم:

- `T arr[n]`
- `T* arr = new T[n]`
- `std::vector<T> arr(n)`

در تمام این موارد داریم آرایه‌ای با اندازه‌ی `n` تعریف می‌کنیم. از آن‌جایی که حالت اول غیرمجاز است، فقط حالت دوم و سوم را توضیح می‌دهیم.

#### تخصیص حافظه

در هنگام تعریف `vector` با اشاره‌گرها کار نمی‌کنیم زیرا نمی‌خواهیم وقتمان با تخصیص حافظه تلف شود.

#### تغییر اندازه

کد زیر نحوه‌ی افزایش اندازه‌ی `vector` را نشان می‌دهد.

```cpp
#include <iostream>
#include <vector>

using namespace std;

int main() {
    int n;
    cin >> n;

    vector<int> a;
    a.resize(10);

    return 0;
}
```

حالا مقایسه کنید با افزایش اندازه در روش `new`.

```cpp
#include <iostream>

using namespace std;

void resize(int* arr, int& n, int final_size) {
    if (final_size <= n)
        return;

    int* temp = new int[final_size];
    for (int i = 0; i < n; ++i)
        temp[i] = arr[i];
    
    delete[] arr;
    arr = temp;
    n = final_size;
}

int main() {
    int n;
    cin >> n;

    int* arr = new int[n];
    resize(arr, n, 10);

    return 0;
}
```

مجبور شدیم که خودمان تابعی بنویسیم! حالا فرض کنید که در یک مسئله آرایه‌ای `double` داشته باشید، دیگر این تابع به درد نمی‌خورد و بالا کل آن را دوباره بنویسید!

#### بررسی حدها

با اینکه این مورد در برنامه‌نویسی مسابقاتی کم‌تر استفاده می‌شود، اما بهتر است بدانید که `vector` متودی دارد که اگر شما بخواهید به ایندکس غیرمجازی دسترسی پیدا کنید، سریعاً برنامه را کرش می‌کند تا متوجه شوید.

#### راحتی استفاده

با متودهایی مانند `push_back()‎` یا `size()‎` می‌توانید کارهایی را انجام دهید که در روش `new` سخت‌تر انجام می‌شود. دو تابعی که معرفی شد به‌ترتیب یک عنصر به آخر `vector` اضافه می‌کند و دیگری، طول `vector` را می‌دهد.

#### مدیریت حافظه

`vector` به‌طور خودکار حافظه‌اش را آزاد می‌کند اما برای روش `new` باید حتماً از `delete[]` استفاده کنید.

#### تطابق با بقیه‌ی کتاب‌خانه‌ها

در هنگامی که تنها مقادیر داخل آرایه مهم است و ایندکس آن مهم نیست، روشی وجود دارد که کد را بسیار خواناتر می‌کند.

```cpp
#include <iostream>
#include <vector>

using namespace std;

int main() {
    int n;
    cin >> n;

    vector<int> a(n);
    for (int& x : a)
        cin >> x;

    for (int& x : a)
        x *= 2;

    return 0;
}
```

به همین راحتی تمام عناصر را خواندیم و ۲ برابر کردیم.

#### کپی

اگر بخواهیم یک `vector` را کپی کنیم، می‌توانیم به‌راحتی از عملگر `=` استفاده کنیم.

```cpp
#include <iostream>
#include <vector>

using namespace std;

int main() {
    int n;
    cin >> n;

    vector<int> a(n);
    vector<int> b = a;

    return 0;
}
```

در حالی که در روش `new` انجام این کار تنها اشاره‌گر آن را کپی می‌کند و نه عناصر را! در نتیجه اگر در شیء دوم عنصری را تغییر دهیم، در شیء اولیه نیز تغییر می‌کند.

### نکات استفاده از `vector`

تا این‌جا به این نتیجه رسیدیم که استفاده از `vector` بسیار بهتر است. حالا به نحوه‌ی استفاده می‌پردازیم.

به‌جای توضیحات بسیار طولانی، تنها نمونه‌هایی ارائه می‌شود به‌همراه توضیحات آن‌ها. تشخیص الگوها بر دوش خواننده است.

| استفاده | توضیحات |
| - | - |
| `vector<int> arr;` | `vector` از جنس `int` با اسم `arr` |
| `vector<double> arr;` | `vector` از جنس `double` با اسم `arr` |
| `vector<int> arr(2);` | `vector` از جنس `int` با اسم `arr` با اندازه‌ی ۲. تمام عناصر مقدار پیش‌فرض (صفر) دارند. |
| `vector<int> arr(2, -1);` | `vector` از جنس `int` با اسم `arr` با اندازه‌ی ۲. تمام عناصر مقدار `-1` دارند. |
| - | - |
| `arr[1]` | دسترسی به عنصر دوم |
| `cin >> arr[1];` | نوشتن به عنصر دوم |
| `cout << arr[1];` | خواندن از عنصر دوم |
| - | - |
| `arr.push_back(1)` | اضافه کردن مقدار ۱ به انتها |
| `arr.pop_back()` | حذف آخرین عنصر |
| `arr.back()` | دسترسی به آخرین عنصر |
| `arr.front()` | دسترسی به اولین عنصر |
| `arr.size()` | طول |
| `arr.resize(4)` | افزایش طول به ۴ |

#### شمارنده‌ها (Iterators)

`vector` شمارنده‌هایی دارد که می‌توانید از آن‌ها استفاده کنید. در اکثر کتاب‌خانه‌ها با شمارنده‌ها کار می‌کنیم تا ایندکس.

| استفاده | توضیحات |
| - | - |
| `arr.begin()` | شمارنده‌ای به ابتدا |
| `arr.end()` | شمارنده‌های به عنصر بعد از عنصر آخر |

در صورتی که `vector` از جنس `int` باشد، ساختار داخلی یک شمارنده مشابه زیر است:

```cpp
class iterator {
private:
    int* pointer;

public:
    iterator(int* pointer) {
        this->pointer = pointer;
    }

    int& operator*() {
        return *pointer;
    }
    
    iterator& operator++() {
        pointer++;
        return *this;
    }
};
```
شمارنده حاوی یک اشاره‌گر به عنصری از آرایه است. از طریق عملگر `*` می‌توان به مقدار آن دسترسی پیدا کرد و از طریق عملگر `++` می‌توان آن را جلو برد.

البته که شمارنده‌های `vector` دو طرفه هستند (هم به جلو می‌روند هم به عقب). مثالی که ارائه شد، فقط یک **مثال** است.

```cpp
#include <iostream>
#include <vector>

using namespace std;

int main() {
    int n;
    std::cin >> n;

    std::vector<int> a(n);
    for (auto it = a.begin(); it != a.end(); ++it)
        cin >> *it;

    return 0;
}
```

در کد بالا، ابتدا مقدار متغیر `it` را برابر شمارنده‌ی ابتدا قرار دادیم. `auto` به C++‎ می‌گوید که خودت نوع این شیء را تشخیص بده و کار ما را راحت کن. سپس حلقه تا زمانی که `it` با شمارنده‌ی بعد از آخر برابر نبود، ادامه پیدا می‌کند.

شاید برایتان سؤال شود که چرا `end()‎` به عنصر بعد از آخر اشاره می‌کند؟

مزایای این روش نسبت به شمارنده‌ی فرضی `last()‎` که به عنصر آخر اشاره می‌کند، به شرح زیر است:

- مقدار `end() - begin()` طول آرایه را می‌دهد.
- سادگی شرط حلقه (به‌جای `it != last() + 1`)`
- اگر تابعی به‌دنبال مقداری در آرایه بود و آن را پیدا نکرد، کافی است `end()` را برگرداند که مطمئنیم در آرایه نیست.

بالاتر اشاره کردیم که می‌توان از طریق `int& x : arr` حلقه‌های خواناتری نوشت. جالب است بدانید که در اصل تمام این مدل حلقه‌ها به حلقه با شمارنده تبدیل می‌شوند! دلیل اینکه آرایه‌های `new` چنین مزیتی ندارند این است که شمارنده ندارند!

در توابع مختلف از شمارنده‌ها استفاده می‌کنیم تا آن عملکرد را فقط به بازه‌ی مشخصی از آرایه محدود کنیم.

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    int n;
    std::cin >> n;

    std::vector<int> a(n);
    sort(a.begin() + 1, a.end());

    return 0;
}
```

کد بالا تمام عناصر جز عنصر اول را مرتب می‌کند.

### نمونه مسئله

برنامه‌ای بنویسید که در خط اول ورودی `n` (تعداد عناصر آرایه) را بخواند.

در خط بعدی، `n` عدد با فاصله نوشته شده.

در خط سوم، عدد `q` تعداد درخواست‌ها به سرور را مشخص می‌کند.

در `q` خط بعدی، اگر ورودی به‌شکل `insert x pos` بود، عدد `x` را در موقعیت `pos` اضافه کنید و اگر ورودی به شکل `erase pos` بود، عنصری که در موقعیت `pos` قرار دارد را حذف کنید.

آرایه‌ی حاصل را چاپ کنید.

توابع لازم:

- `vector.insert(iterator, value)`: اضافه کردن مقدار جدید در مکان مشخص‌شده
- `vector.erase(iterator)`: حذف عنصر در مکان مشخص‌شده

```
Input:
4
1 4 6 3
2
insert 4 1
erase 4
```

```cpp
#include <iostream>
#include <vector>
#include <string>

using namespace std;

int main() {
    int n;
    cin >> n;

    vector<int> arr(n);
    for (auto& x : arr)
        cin >> x;
    
    int q;
    cin >> q;

    for (int i = 0; i < q; ++i) {
        string command;
        cin >> command;

        if (command == "insert") {
            int x, pos;
            cin >> x >> pos;

            arr.insert(arr.begin() + pos, x);
        }
        else {
            int pos;
            cin >> pos;

            arr.erase(arr.begin() + pos);
        }
    }

    for (auto& x : arr)
        cout << x << ' ';
    cout << endl;

    return 0;
}
```
